// src/utils/sql/dialects.ts
export type DialectId = "postgres" | "mysql" | "sqlite";

export interface DialectRenderer {
  id: DialectId;
  q(id: string): string; // quote identifier
  type(sqlType: string): string; // normalize types if needed
  identity(baseType: string, isPrimaryKey: boolean): string; // PK identity syntax
  now(): string; // current timestamp fn
  supportsSchema(): boolean; // whether schema qualifier is valid
}

export const PostgresRenderer: DialectRenderer = {
  id: "postgres",
  q: (id) => `"${id.replace(/"/g, '""')}"`,
  type: (t) => t,
  identity: (t, isPK) => (isPK ? `${t} GENERATED BY DEFAULT AS IDENTITY` : t),
  now: () => "NOW()",
  supportsSchema: () => true,
};

export const MySqlRenderer: DialectRenderer = {
  id: "mysql",
  q: (id) => `\`${id.replace(/`/g, "``")}\``,
  type: (t) => t,
  identity: (t, isPK) => (isPK ? `${t} AUTO_INCREMENT` : t),
  now: () => "CURRENT_TIMESTAMP",
  supportsSchema: () => false, // use database instead
};

export const SqliteRenderer: DialectRenderer = {
  id: "sqlite",
  q: (id) => `"${id.replace(/"/g, '""')}"`,
  type: (t) => t, // you can map types to SQLite affinities if desired
  identity: (t, isPK) =>
    // In SQLite, only INTEGER PRIMARY KEY (optionally AUTOINCREMENT) works as identity.
    isPK ? "INTEGER PRIMARY KEY AUTOINCREMENT" : t,
  now: () => "CURRENT_TIMESTAMP",
  supportsSchema: () => false,
};
